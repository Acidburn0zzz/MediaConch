Spec Component Number,Spec Component Name,Related component description from current Matroska spec (http://matroska-org.github.io/libebml/specs.html),Related component discription from Nilsson EBML RFC Draft (http://matroska.org/technical/specs/rfc/index.html),Submitted to matroska-devel,Proposed Revision,,,,,,,,,,
1,Abstract,"""EBML was designed to be a simplified binary extension of XML for the purpose of storing and manipulating data in a hierarchical form with variable field lengths.""","""The extensible binary markup language, EBML, is a binary language for storing hierarchical, typed in data in a compact, yet easily parsed format.""",Yes,"""“EBML is designed to be a compact and simple binary storage format, inspired by XML, for the purpose of storing and manipulating all sorts of digital content and metadata in a hierarchical form with variable field length.""",,,,,,,,,,
2,About this document,None,"""This document is currently in its draft stage and is subject to changes. The contents should not be relied upon for implementational purposes.  The key words ""MUST"", ""MUST NOT"", ""REQUIRED"", ""SHALL"", ""SHALL NOT"", ""SHOULD"", ""SHOULD NOT"", ""RECOMMENDED"", ""MAY"", and ""OPTIONAL"" in this document are to be interpreted as described in RFC 2119 [RFC2119]. The definitions in this document uses ABNF [ABNF]. Note that string terminals are case insensitive in ABNF. The interpretation of binary values has been slightly altered so that every bit must be explicitly printed, e.g. %b0 is one zero bit while %b000 represents three zero bits. The following (re)definitions are used throughout this document: BIT  = %b1 / %b0; BYTE = OCTET; WSP  = SP / HTAB / CR / LF""",Yes,,,,,,,,,,,
3,Introduction,None,The Extensible Binary Markup Language EBML was designed to be a simplified binary version of XML for the purpose of storing and manipulating data in a hierarchical form with variable field lengths. Specifically EBML was designed as the framework language for the video container format Matroska. Some of the advantages of EBML are:,Yes,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,- Possibility for compatibility between different versions of binary languages defined in EBML. A rare property of binary format that otherwise often needs careful consideration beforehand.,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,- Unlimited size of data payload.,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"- Can be both generated and read as a stream, without knowing the data size beforehand.",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"- Often very space efficient, even compared to other binary representations of the same data.",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,Some of the EBML disadvantages are:,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"- No references can be made between EBML files, such as includes or inherits. Every EBML document is a self contained entity. The data stored in EBML may of course reference other resources.",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,- No compositioning process to merge two or more EBML languages currently exists.,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"This document describes the EBML binary syntax, its semantic interpretation and the syntax of a textual document type definition format used to define the rules and constraints of an EBML language. BNF is used throughout this document to augment the description and make it more formalized. It must however be noted that two different formats are described in this document, with two different BNFs. One for the binary format in chapter 2 and one for the document type definition in the rest of the document. To avoid confusion different token names has been chosen. The BNFs can be viewed in full in the appendices.",,,,,,,,,,,,
4,EBML Principle,"EBML is short for Extensible Binary Meta Language. EBML specifies a binary and octet (byte) aligned format inspired by the principle of XML. EBML itself is a generalized description of the technique of binary markup. Like XML, it is completely agnostic to any data that it might contain. Therein, the Matroska project is a specific implementation using the rules of EBML: It seeks to define a subset of the EBML language in the context of audio and video data (though it obviously isn't limited to this purpose). The format is made of 2 parts: the semantic and the syntax. The semantic specifies a number of IDs and their basic type and is not included in the data file/stream.", None,N/A,,,,,,,,,,,
,,,,,,,,,,,,,,,
,,"Just like XML, the specific ""tags"" (IDs in EBML parlance) used in an EBML implementation are arbitrary. However, the semantic of EBML outlines general data types and ID's.",,,,,,,,,,,,,
,,,,,,,,,,,,,,,
,,The known basic types are:,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
,,"•  Signed Integer - Big-endian, any size from 1 to 8 octets",,,,,,,,,,,,,
,,"•  Unsigned Integer - Big-endian, any size from 1 to 8 octets",,,,,,,,,,,,,
,,"•  Float - Big-endian, defined for 4 and 8 octets (32, 64 bits)",,,,,,,,,,,,,
,,"•  String - Printable ASCII (0x20 to 0x7E), zero-padded when needed",,,,,,,,,,,,,
,,"•  UTF-8 - Unicode string, zero padded when needed (RFC 2279)",,,,,,,,,,,,,
,,"•  Date - signed 8 octets integer in nanoseconds with 0 indicating the precise beginning of the millennium (at 2001-01-01T00:00:00,000000000 UTC)",,,,,,,,,,,,,
,,•  master-element - contains other EBML sub-elements of the next lower level,,,,,,,,,,,,,
,,•  Binary - not interpreted by the parser,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
,,"As well as defining standard data types, EBML uses a system of Elements to make up an EBML ""document."" Elements incorporate an Element ID, a descriptor for the size of the element, and the binary data itself. Futher, Elements can be nested, or contain, Elements of a lower ""level.""",,,,,,,,,,,,,
,,,,,,,,,,,,,,,
,,"Element IDs are outlined as follows, beginning with the ID itself, followed by the Data Size, and then the non-interpreted Binary itself:",,,,,,,,,,,,,
,,,,,,,,,,,,,,,
,,•  Element ID coded with an UTF-8 like system:,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
,,"bits, big-endian",,,,,,,,,,,,,
,,•  1xxx xxxx  - Class A IDs (2^7 -1 possible values) (base 0x8X),,,,,,,,,,,,,
,,•  01xx xxxx xxxx xxxx  - Class B IDs (2^14-1 possible values) (base 0x4X 0xXX),,,,,,,,,,,,,
,,•  001x xxxx xxxx xxxx xxxx xxxx  - Class C IDs (2^21-1 possible values) (base 0x2X 0xXX 0xXX),,,,,,,,,,,,,
,,•  0001 xxxx xxxx xxxx xxxx xxxx xxxx xxxx - Class D IDs (2^28-1 possible values) (base 0x1X 0xXX 0xXX 0xXX),,,,,,,,,,,,,
,,,,,,,,,,,,,,,
,,Some Notes:,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
,,•  The leading bits of the Class IDs are used to identify the length of the ID. The number of leading 0's + 1 is the length of the ID in octets. We will refer to the leading bits as the Length Descriptor.,,,,,,,,,,,,,
,,"•  Any ID where all x's are composed entirely of 1's is a Reserved ID, thus the -1 in the definitions above.",,,,,,,,,,,,,
,,•  The Reserved IDs (all x set to 1) are the only IDs that may change the Length Descriptor.,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
,,"•  Data size, in octets, is also coded with an UTF-8 like system:",,,,,,,,,,,,,
,,,,,,,,,,,,,,,
,,"bits, big-endian",,,,,,,,,,,,,
,,•  1xxx xxxx - value 0 to 2^7-2,,,,,,,,,,,,,
,,•  01xx xxxx xxxx xxxx - value 0 to 2^14-2,,,,,,,,,,,,,
,,•  001x xxxx xxxx xxxx xxxx xxxx - value 0 to 2^21-2,,,,,,,,,,,,,
,,•  0001 xxxx xxxx xxxx xxxx xxxx xxxx xxxx  - value 0 to 2^28-2,,,,,,,,,,,,,
,,•  0000 1xxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx - value 0 to 2^35-2,,,,,,,,,,,,,
,,•  0000 01xx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx  - value 0 to 2^42-2,,,,,,,,,,,,,
,,•  0000 001x xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx  - value 0 to 2^49-2,,,,,,,,,,,,, 
,,•  0000 0001 xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx - value 0 to 2^56-2,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
,,"Since modern computers do not easily deal with data coded in sizes greater than 64 bits, any larger Element Sizes are left undefined at the moment. Currently, the Element Size coding allows for an Element to grow to 72000 To, i.e. 7x10^16 octets or 72000 terabytes, which will be sufficient for the time being.",,,,,,,,,,,,,
,,,,,,,,,,,,,,,
,,"There is only one reserved word for Element Size encoding, which is an Element Size encoded to all 1's. Such a coding indicates that the size of the Element is unknown, which is a special case that we believe will be useful for live streaming purposes. However, avoid using this reserved word unnecessarily, because it makes parsing slower and more difficult to implement.",,,,,,,,,,,,,
,,,,,,,,,,,,,,,
,,•  Data,,,,,,,,,,,,,
,,"•  Integers are stored in their standard big-endian form (no UTF-like encoding), only the size may differ from their usual form (24 or 40 bits for example).",,,,,,,,,,,,,
,,•  The Signed Integer is just the big-endian representation trimmed from some 0x00 and 0xFF where they are not meaningful (sign). For example -2 can be coded as 0xFFFFFFFFFFFFFE or 0xFFFE or 0xFE and 5 can be coded 0x000000000005 or 0x0005 or 0x05.,,,,,,,,,,,,,
5,Structure,None,"Syntactically an EBML document is a list of EBML elements. Each element has three parts; an element ID, a size descriptor and the element data payload. The element data payload is then either data, implicitly typed by the element ID, or a list of EBML elements.",Yes,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,EBML       = *ELEMENT,,,,,,,,,,,,
,,,ELEMENT    = ELEMENT_ID SIZE DATA,,,,,,,,,,,,
,,,DATA       = VALUE / *ELEMENT,,,,,,,,,,,,
,,,ELEMENT_ID = VINT,,,,,,,,,,,,
,,,SIZE       = VINT,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"EBML uses big endian/network order byte order, i.e. most significant bit first. All of the tokens above are byte aligned.",,,,,,,,,,,,
6,Variable size integer,None,"For both element ID and size descriptor EBML uses a variable size integer, coded according to a schema similar to that of UTF-8 [UTF-8] encoding. The variable size integer begins with zero or more zero bits to define the width of the integer. Zero zeroes means a width of one byte, one zero a width of two bytes etc. The zeroes are followed by a marker of one set bit and then follows the actual integer data. The integer data consists of alignment data and tail data. The alignment data together with the width descriptor and the marker makes up one ore more complete bytes. The tail data is as many bytes as there were zeroes in the width descriptor, i.e. width-1.",Yes,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,VINT  = VINT_WIDTH VINT_MARKER VINT_DATA,,,,,,,,,,,,
,,,VINT_WIDTH  = *%b0,,,,,,,,,,,,
,,,VINT_MARKER = %b1,,,,,,,,,,,,
,,,VINT_DATA  = VINT_ALIGNMENT VINT_TAIL,,,,,,,,,,,,
,,,VINT_ALIGNMENT = *BIT,,,,,,,,,,,,
,,,VINT_TAIL  = *BYTE,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"An alternate way of expressing this is the following definition, where the width is the number of levels of expansion.",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,VINT = ( %b0 VINT 7BIT ) / ( %b1 7BIT ),,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,Some examples of the encoding of integers of width 1 to 4. The x:es represent bits where the actual integer value would be stored.,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,   Width  Size  Representation,,,,,,,,,,,,
,,,1    2^7   1xxx xxxx,,,,,,,,,,,,
,,,2    2^14  01xx xxxx  xxxx xxxx,,,,,,,,,,,,
,,,3    2^21  001x xxxx  xxxx xxxx  xxxx xxxx,,,,,,,,,,,,
,,,4    2^28  0001 xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx,,,,,,,,,,,,
7,Element ID,None,"The EBML element ID is encoded as a variable size integer with, by default, widths up to 4. Another maximum width value can be set by setting another value to EBMLMaxIDWidth in the EBML header. See section 5.1. IDs are always encoded in their shortest form, e.g. 1 is always encoded as 0x81 and never as 0x4001. This limits the number of IDs in every class with the number of IDs in the previous classes. Furthermore, values with all data bits set to 1 and all data bits set to 0 are reserved, hence the effective number of IDs are as follows for different widths. Note that the shortest encoding form for 127 is 0x407f since 0x7f is reserved.",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,Class; Width; Number of IDs,,,,,,,,,,,,
,,,A ; 1 ; 2^7-2 = 126,,,,,,,,,,,,
,,,B ; 2 ; 2^14-2^7  = 16 256,,,,,,,,,,,,
,,,C ; 3 ; 2^21-2^14 =   2 080 768,,,,,,,,,,,,
,,,D ; 4 ; 2^28-2^21 = 266 338 304,,,,,,,,,,,,
8,Element Data Size,None,"The EBML element data size is encoded as a variable size integer with, by default, widths up to 8. Another maximum width value can be set by setting another value to EBMLMaxSizeWidth in the EBML header. See section 5.1. There is a range overlap between all different widths, so that 1 encoded with width 1 is semantically equal to 1 encoded with width 8. This allows for the element data to shrink without having to shrink the width of the size descriptor.",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"Values with all data bits set to 1 means size unknown, which allows for dynamically generated EBML streams where the final size isn't known beforehand. The element with unknown size MUST be an element with an element list as data payload. The end of the element list is determined by the ID of the element. When an element that isn't a sub-element of the element with unknown size arrives, the element list is ended.",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"Since the highest value is used for unknown size the effective maximum data size is 2^56-2, using variable size integer width 8.",,,,,,,,,,,,
,,,,,,,,,,,,,,,
9,Values,None,"Besides having an element list as data payload an element can have its data typed with any of seven predefined data types. The actual type information isn't stored in EBML but is inferred from the document type definition through the element ID. The defined data types are signed integer, unsigned integer, float, ASCII string, UTF-8 string, date and binary data.",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,VALUE = INT / UINT / FLOAT / STRING / DATE / BINARY,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,INT = *8BYTE,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"Signed integer, represented in two's complement notation, sizes from 0-8 bytes. A zero byte integer represents the integer value 0.",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,UINT = *8BYTE,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"Unsigned integer, sizes from 0-8 bytes. A zero byte integer represents the integer value 0.",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,FLOAT = *1( 4BYTE / 8BYTE / 10BYTE ),,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"IEEE float [FLOAT], sizes 0, 4, 8 or 10 bytes. A zero byte float represents the float value 0.0.",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,PADDING = %x00,,,,,,,,,,,,
,,,STRING  = *BYTE *PADDING,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,UTF-8 [UTF-8] encoded Unicode [UNICODE] string. A string MAY be zero padded at the end. Note that a string can be of zero length.,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,DATE = 8BYTE,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"Signed, 64-bit (8 byte) integer describing the distance in nanoseconds to the beginning of the millennium (2001-01-01 00:00:00 UTC).",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,BINARY = *BYTE,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"Binary data, i.e. not interpreted at the EBML level.",,,,,,,,,,,,
10,Semantic Interpretation,None,"Every element has several properties defined in the document type definition, which are needed for the correct syntactical and semantic handling of the information. These properties are name, parent, ID, cardinality, value restrictions, default value, value type and child order.",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"To syntactically parse EBML data we need to know the element value types, and to semantically interpret that data we also need to know the element IDs and element names. Elements can have a default value, so for the final presentation of the parsed EBML data elements that wasn't stored in the data may show up. Finally elements may have restrictions in terms of which parent or parents they may have, the number of times they may occur in the EBML data, their order in the document and various additional restrictions of their data payload.",,,,,,,,,,,,
11,Name Property,None,"The name is the symbolic identifier of an element and has a 1:1 mapping to the element ID. Only alphanumeric characters and underscores may be used for the name. It may not start with a number. Names are treated case insensitive, i.e. ""Name"" is the same identifier as ""name"".",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,NAME = [A-Za-z_] 1*[A-Za-z_0-9],,,,,,,,,,,,
12,Value Type Property,None,"There is no way of knowing whether or not to look for sub elements with only the information presented in the EBML data. Hence the element value type is the most important information in the EBML DTD. In addition to the value types defined in section 2.4 an element can also be of the type ""container"", which simply means that its content is more elements.",,,,,,,,,,,,
13,ID Property,None,"Every element must have an ID associated, as defined in section 2.2.  These IDs are expressed in the hexadecimal representation of their encoded form, e.g. 1a45dfa3.",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,ID = 1*( 2HEXDIG ),,,,,,,,,,,,
14,Defaut Value Property,None,"Every non-container MAY be assigned a default value. If so, its value will be added to the interpretation of the EBML data if no element with another value exists in the data.",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"As an example, consider this EBML DTD:",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,Weight := 4101 {,,,,,,,,,,,,
,,,WeightValue := 41a1 uint;,,,,,,,,,,,,
,,,"WeightUnit  := 41a2 string [ def:""kilogram"" ];",,,,,,,,,,,,
,,,},,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"If the Weight element only contains the WeightValue element, the WeightUnit element with value ""kilogram"" will be added when the information is semantically processed. A WeightUnit element with another value would of course override the default.",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"The default value can also be a symbol referring back to a previously seen symbol. If however no such symbol has been seen, i.e. it has not been encoded into the EBML data and has no default value, the element will not be added as a child on the semantic level.",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,Weight := 4101 {,,,,,,,,,,,,
,,,WeightValue := 41a1 uint;,,,,,,,,,,,,
,,,WeightUnit  := 41a2 string [ def:WeightUnit ];,,,,,,,,,,,,
,,,},,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"In this example all Weight elements will use the same weight unit as the previous one. To ensure that the first one has a value its cardinality should be set to ""1"". See section 3.6.",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,DEFAULT = INT_DEF / UINT_DEF / FLOAT_DEF / STRING_DEF /,,,,,,,,,,,,
,,,DATE_DEF / BINARY_DEF / NAME,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,DATE_VALUE = *1DIGIT 2DIGIT 2DIGIT,,,,,,,,,,,,
,,,"*1(%x54 2DIGIT "":"" 2DIGIT "":"" 2DIGIT",,,,,,,,,,,,
,,,"*1( ""."" *1DIGIT ))",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"INT_DEF    = *1""-"" 1*DIGIT",,,,,,,,,,,,
,,,UINT_DEF   = 1*DIGIT,,,,,,,,,,,,
,,,"FLOAT_DEF  = INT ""."" 1*DIGIT *1( ""e"" *1( ""+""/""-"" ) 1*DIGIT )",,,,,,,,,,,,
,,,DATE_DEF   = INT_DEF / DATE_VALUE,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"STRING_DEF = (""0x"" 1*( 2HEXDIG )) / ( %x22 *(%x20-7e) %x22 )",,,,,,,,,,,,
,,,BINARY_DEF = STRING_DEF,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"The date default value is either described as the integer in its encoded form or in the ISO short format; YYYYMMDD followed by the string literal T, the time as HH:MM:DD and finally and optionally the fractions as .F with an optional numbers of F for precision. Some examples:",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,ExampleInt := c0 int [ def:-114; ],,,,,,,,,,,,
,,,ExampleUInt := c1 uint [ def:0; ],,,,,,,,,,,,
,,,ExampleFloat := c2 float [ def:6.022E23 ],,,,,,,,,,,,
,,,ExampleDate := c3 date [ def:20011224T15:00:03.21; ],,,,,,,,,,,,
,,,ExampleBinary := c5 binary [ def:0x4944337632; ],,,,,,,,,,,,
,,,"ExampleString := c6 string [ def:""Sweden""; ]",,,,,,,,,,,,
15,Parent property,None,To place the elements in a hierarchical structure we need relational information about the elements. In the EBML DTD this is expressed as the possible parents an element may have. This can be expressed in two ways: an explicit list of allowed parents or a generic definition of allowed insertion depth.,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"PARENTS = NAME / ( NAME "","" PARENTS )",,,,,,,,,,,,
,,,"LEVEL   = 1*DIGIT *1( "".."" *DIGIT )",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,An element with neither parents nor level defined is assumed to exist on the top level in the EBML document. An element can not have both a parent and a level property.,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"The following example contains two elements, Envelope and Letter. The Letter must, if it exists in the document, be a child of Envelope and Envelop must, if it exists in the document, reside at the top level.",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,Envelope := a0 container;,,,,,,,,,,,,
,,,Letter := b0 string [ parent:Envelope; ],,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"The following example expresses the exact same relationships, but in an abbreviated syntax.",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,Envelope := a0 container {,,,,,,,,,,,,
,,,Letter := b0 string;,,,,,,,,,,,,
,,,},,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,The following example shows that the abbreviated syntax can't be used to solve all relations. Here the Letter element can be a child in both the Envelope element and the Trashcan element. The explicit parent information is merged with the one expressed with the abbreviated syntax.,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,Envelope := a0 container {,,,,,,,,,,,,
,,,Letter := b0 string [ parent:Trashcan; ];,,,,,,,,,,,,
,,,},,,,,,,,,,,,
,,,Trashcan := a1 container;,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,The following example demonstrates the usage of level instead of parent. The element Void may occur at any place in the EBML document.,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,Void  := ec binary [ level:1..; card:*; ],,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"This is an example similar to the one above, but using containers instead. The children of the parent to the SHA1 element may be pushed down to the level where ""%children;"" is, i.e. if used with the first Letter-Envelope example the Envelope may contain an SHA1 element which may contain an SHA1Content element which may contain a Letter element. A container element with a level property MUST NOT use undefined size as described in section 2.3, since then the end of the element can not be determined in all cases.",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,SHA1 := 190babe5 container [ level:1..; card:*; ] {,,,,,,,,,,,,
,,,SHA1Content := 20110f container {,,,,,,,,,,,,
,,,%children;,,,,,,,,,,,,
,,,},,,,,,,,,,,,
,,,SHA1Hash := 20110e binary;,,,,,,,,,,,,
,,,},,,,,,,,,,,,
16,Cardinality property,None,"The cardinality of an element declares how many times an element may occur in its current scope. By default an element may only occur at most once in a scope, e.g. if the element Weight has been defined as a child to Brick, no more than one Weight element can be used in every Brick element. The cardinality can however be altered from the default to any of the following. Note that this affects all scopes that the element can be inserted into.",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,Symbol;Interpretation,,,,,,,,,,,,
,,,*;Zero or more occurrences.,,,,,,,,,,,,
,,,?;Zero or one occurrence (default).,,,,,,,,,,,,
,,,1;Exactly one occurrence.,,,,,,,,,,,,
,,,"""+;One or more occurrences.""",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"CARDINALITY = ""*"" / ""?"" / ""1"" / ""+""",,,,,,,,,,,,
17,Child order property,None,The child order property only applies to container elements. It simply declares if the children of the element must appear in the order they are defined in or not. By default this restriction is imposed on all children to all elements. The advantage of ordered elements in combination with default values is that the EBML decoder will know immediately once an element is skipped and can output the appropriate default value instead.,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"YES     = ""yes"" / ""1""",,,,,,,,,,,,
,,,"NO      = ""no"" / ""0""",,,,,,,,,,,,
,,,ORDERED = YES / NO,,,,,,,,,,,,
18,Value restriction properties,None,Every element may impose additional constraints upon its value. These constraints are only used to validate data during encoding and makes no difference for the decoding or interpretation of the encoded data. The available constraints and syntax differs between different types of elements.,,,,,,,,,,,,
19,Range,None,"The range of an element value determines the allowed values that the element value may have. The range is expressed as one or more specific values or spans of allowed values, with the exception of floats and dates where only spans are allowed.",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"RANGE_LIST = RANGE_ITEM / ( RANGE_ITEM S "","" S RANGE_LIST )",,,,,,,,,,,,
,,,RANGE_ITEM = INT_RANGE / UINT_RANGE / FLOAT_RANGE /,,,,,,,,,,,,
,,,STRING_RANGE / DATE_RANGE / BINARY_RANGE,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"For integers the range is a list of values and open or closed ranges, e.g. ""0,1"", ""1..5"" and ""..-1,1.."". The final allowed range is a union of all listed ranges. If a value matches any of the listed ranges it is considered valid.",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"INT_RANGE = INT_DEF / ( INT_DEF "".."" ) / ( "".."" INT_DEF ) /",,,,,,,,,,,,
,,,"( INT_DEF "".."" INT_DEF )",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"Unsigned integers is similar, but can not have its range open to the left.",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"UINT_RANGE  = UINT_DEF *1( "".."" UINT_DEF )",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,Floats can have both inclusive and exclusive end points of its ranges.,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"FLOAT_RANGE = ( (""<"" / ""<=""/ "">"" / "">="") FLOAT_DEF ) /",,,,,,,,,,,,
,,,"( FLOAT_DEF ""<""/""<="" "".."" ""<""/""<="" FLOAT_DEF )",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"Date ranges has the same syntax and semantics as integer ranges, except that the actual date can be described either as an integer or in ISO short format.",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"DATE_RANGE = ( DATE_DEF "".."" ) / ( "".."" DATE_DEF ) /",,,,,,,,,,,,
,,,"( DATE_DEF "".."" DATE_DEF )",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"String and binary ranges limits the range for each character/byte in the string. Note that in the string case this is for the unencoded unicode data, i.e. the possible range is larger than 0-255, which is the bounding range for binary data.",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,STRING_RANGE = UINT_RANGE,,,,,,,,,,,,
,,,BINARY_RANGE = UINT_RANGE,,,,,,,,,,,,
20,Size,None,The size of an element value is simply the number of bytes it occupies in its encoded form. That means that the size of a string element value need not be the same as the string length.,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"SIZE_LIST = UINT_RANGE / ( UINT_RANGE S "","" S SIZE_LIST )",,,,,,,,,,,,
21,Document Type definition,None,"The EBML document type definition, EDTD, is an ASCII based language that allows for the constraints and relations described in chapter 3 to be described in a way that is both human and computer readable. Syntactically it consists of blocks, not unlike most programming languages, which contains definitions/declarations similar to BNF. The format is largely whitespace insensitive, case insensitive and supports both C-style (LCOMMENT) and C++-style (BCOMMENT) comments. The BNF lines in this chapter is somewhat simplified for readability compared to the complete BNF in Appendix B.",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,COMMENT = LCOMMENT / BCOMMENT,,,,,,,,,,,,
,,,S       = *WSP / ( *WSP COMMENT *WSP ) ; Optional white spaces,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"On the top level of the EDTD only three different blocks are currently defined, header declarations, type definitions and element definitions.",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,DTD     = *( S / HBLOCK / TBLOCK / EBLOCK ),,,,,,,,,,,,
22,Header declarations,None,"The meaning of the header declaration is to declare what values should be put into the elements of the header, should they differ from the default values. The header declaration block is written as ""declare header"" followed by curly brackets that encloses the block of statements. The actual statements are very straightforward, the element name followed by "":="" followed by the value, as described in section 3.4, followed by "";"". There MUST only be one header declaration block in a DTD.",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"HBLOCK    = ""declare"" WSP ""header"" S ""{"" *(S / STATEMENT) ""}""",,,,,,,,,,,,
,,,"STATEMENT = NAME S "":="" S DEFS S "";""",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,Since the DocType element has no default value it MUST be declared in the EDTD. It is RECOMMENDED that the EBMLVersion is also declared. Such a declaration could look like this:,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,declare header {,,,,,,,,,,,,
,,,"DocType := ""xhtml"";",,,,,,,,,,,,
,,,EBMLVersion := 1;,,,,,,,,,,,,
,,,},,,,,,,,,,,,
23,Type definitions,None,"Type definitions is a way to create types with more mnemonic names, making the DTD both smaller and easier to read. The type definitions block is written as ""define types"" followed by a block of statements enclosed in curly brackets. Each statement is a type name followed by "":="" followed by the type on which this type should be based on, optionally followed by a list of properties, enclosed in angle brackets. The type names follows the same rules as element names, but lives in another namespace, i.e. there may be an element with the same name as a type.",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"TBLOCK = ""define"" S WSP ""types"" S ""{"" *(S / DTYPE) ""}""",,,,,,,,,,,,
,,,"DTYPE  = NAME S "":="" S TYPE S (PROPERTIES S *1"";"")/"";""",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"The base type may be another defined type, as long as the definitions are made in order, as shown in the following example.",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,define types {,,,,,,,,,,,,
,,,digits := int;,,,,,,,,,,,,
,,,number := digits;,,,,,,,,,,,,
,,,},,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"The type definition then both allows for types as described in section 2.4 and NAME, which refers to types previously defined in the document.",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,TYPE  = VTYPE / CTYPE,,,,,,,,,,,,
,,,"VTYPE = ""int"" / ""uint"" / ""float"" / ""string"" / ""date"" /",,,,,,,,,,,,
,,,binary / NAME,,,,,,,,,,,,
,,,"CTYPE = ""conainer"" / NAME",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"If the type definition has no list of properties, the statement is ended with "";"". If the it has a property list, ending the statement with "";"" is optional.",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"PROPERTIES = ""["" S 1*PROPERTY S ""]""",,,,,,,,,,,,
,,,"PROPERTY   = PROP_NAME S "":"" S PROP_VALUE S "";""",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,Some examples:,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,crc32 := binary [ size:4; ],,,,,,,,,,,,
,,,sha1  := binary [ size:20; ],,,,,,,,,,,,
,,,bool  := uint [ range:0..1; ],,,,,,,,,,,,
,,,us_printable := binary [ range:32..126; ],,,,,,,,,,,,
24,Element definitions,None,"The element definitions is the real purpose of the DTD. The element definitions block is written as ""define elements"" followed by a block of statements enclosed in curly brackets. Each statement can be either a simple statement similar to the type definition statements, or a block statement, containing more statements.",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"EBLOCK   = ""define"" WSP ""elements"" S ""{"" *(S / ELEMENT) ""}""",,,,,,,,,,,,
,,,"DELEMENT = VELEMENT / CELEMENT / ""%children;""",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"The simple statements are typically used for value elements and consists of a name followed by "":="", id, type and optionally properties.",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"VELEMENT = NAME S "":="" S ID WSP S TYPE S (PROPERTIES S *1"";"")/"";""",,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,The block version of the element statements are only used to express parent-children relations. See section 3.5.,,,,,,,,,,,,
,,, ,,,,,,,,,,,,
,,,"CELEMENT = NAME S "":="" S ID WSP S ""container"" S *1PROPERTIES S",,,,,,,,,,,,
,,,"(""{"" *DELEMENT ""}"")/"";""",,,,,,,,,,,,
25,EBML standard elements,None,"EBML defines a small set of elements that can be used in any EBML application. An EBML document MUST begin with an EBML header consisting of the EBML element. Generally speaking it would be possible to define default values to all elements in the EBML element in the document type definition for an application, and thus being able to represent the entire header without have a single byte written. However, in order to be able to identify EBML documents between applications it is REQUIRED that all EBML elements whose values differs from the standard defaults in this document, are written in EBML data. In practice that means that at least the DocType is always stored in all EBML documents.",,,,,,,,,,,,
26,Element Semantic - EBML,Set the EBML characteristics of the data to follow. Each EBML document has to start with this.,The EBML element is a container for the EBML header. EBML := 1a45dfa3 container [ card:+; ],,,,,,,,,,,,
27,Element Semantic - EBMLVersion,The version of EBML parser used to create the file.,EBMLVersion is the version of EBML to which the document conforms to. EBMLVersion := 4286 uint [ def:1; parent:EBML; ],,,,,,,,,,,,
28,Element Semantic - EBMLReadVersion,The minimum EBML version a parser has to support to read this file.,The minimum EBML version a parser has to support in order to read the document. EBMLReadVersion := 42f7 uint [ def:1; parent:EBML; ],,,,,,,,,,,,
29,Element Semantic - EBMLMaxIDLength,The maximum length of the IDs you'll find in this file (4 or less in Matroska).,The maximum width of the IDs used in this document. It is RECOMMENDED to not have wider IDs than 4. EBMLMaxIDWidth may be larger than any actual width used in the document. EBMLMaxIDWidth := 42f2 uint [ def:4; parent:EBML; ],,,,,,,,,,,,
30,Element Semantic - EBMLMaxSizeLength,The maximum length of the sizes you'll find in this file (8 or less in Matroska). This does not override the element size indicated at the beginning of an element. Elements that have an indicated size which is larger than what is allowed by EBMLMaxSizeLength shall be considered invalid.,The maximum width of the size descriptors used in this document. It is RECOMMENDED to not have wider size descriptors than 8. EBMLMaxSizeWidth may be larger than any actual width used in the document. EBMLMaxSizeWidth := 42f3 uint [ def:8; parent:EBML; ],,,,,,,,,,,,
31,Element Semantic - DocType,A string that describes the type of document that follows this EBML header ('matroska' in our case).,An ASCII string that identifies the type of the document. DocType := 4282 binary [ range:32..126; parent:EBML; ],,,,,,,,,,,,
32,Element Semantic - DocTypeVersion,The version of DocType interpreter used to create the file.,DocTypeVersion is the version of document type to which the document conforms to. DocTypeVersion := 4287 uint [ def:1; parent:EBML; ],,,,,,,,,,,,
33,Element Semantic - DocTypeReadVersion,The minimum DocType version an interpreter has to support to read this file.,The minimum DocType version an interpreter has to support in order to read the document. DocTypeReadVersion := 4285 uint [ def:1; parent:EBML; ],,,,,,,,,,,,
34,Element Semantic - CRC32,"The CRC is computed on all the data from the last CRC element (or start of the upper level element), up to the CRC element, including other previous CRC elements. All level 1 elements should include a CRC-32.",The CRC32 container can be placed around any EBML element or elements. The value stored in CRC32Value is the result of the CRC-32 [CRC32] checksum performed on the other child elements.,,,,,,,,,,,,
,,,CRC32 := c3 container [ level:1..; card:*; ] {,,,,,,,,,,,,
,,,%children;,,,,,,,,,,,,
,,,CRC32Value := 42fe binary [ size:4; ],,,,,,,,,,,,
,,,},,,,,,,,,,,,
35,Element Semantic - Void,"Used to void damaged data, to avoid unexpected behaviors when using damaged data. The content is discarded. Also used to reserve space in a sub-element for later use.","The void element can be used as padding to prepare for more data, or to fill space when data has been removed. It should simply be ignored when the document is interpreted. Void  := ec binary [ level:1..; card:*; ]",,,,,,,,,,,,
36,Element Semantic - SignatureSlot,Contain signature of some (coming) elements in the stream.,None,,,,,,,,,,,,
37,Element Semantic - SignatureAlgo,"Signature algorithm used (1=RSA, 2=elliptic).",None,,,,,,,,,,,,
38,Element Semantic - SignatureHash,"Hash algorithm used (1=SHA1-160, 2=MD5).",None,,,,,,,,,,,,
39,Element Semantic - SignaturePublicKey,The public key to use with the algorithm (in the case of a PKI-based signature).,None,,,,,,,,,,,,
40,Element Semantic - Signature,The signature of the data (until a new.,None,,,,,,,,,,,,
41,Element Semantic - SignatureElements,Contains elements that will be used to compute the signature.,None,,,,,,,,,,,,
42,Element Semantic - SignatureElementList,A list consists of a number of consecutive elements that represent one case where data is used in signature. Ex:Cluster|Block|BlockAdditional means that the BlockAdditional of all Blocks in all Clusters is used for encryption.,None,,,,,,,,,,,,
43,Element Semantic - SignedElement,An element ID whose data will be used to compute the signature.,None,,,,,,,,,,,,